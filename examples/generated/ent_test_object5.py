####################
# Code generated by EntPy - do not modify manually!
####################

from __future__ import annotations
from entpy import (
    Ent,
    generate_uuid,
    EntNotFoundError,
    ExecutionError,
    Action,
    Decision,
    ValidationError,
)
from uuid import UUID
from datetime import datetime, UTC
from evc import ExampleViewerContext
from database import get_session
from .ent_model import EntModel
from .ent_query import EntQuery
from ent_test_object5_schema import EntTestObject5Schema
from entpy import Field
from sentinels import NOTHING, Sentinel  # type: ignore[import-untyped]
from sqlalchemy import Boolean
from sqlalchemy import String
from sqlalchemy import select, func, Result
from sqlalchemy.orm import Mapped, mapped_column
from typing import TypeVar


class EntTestObject5Model(EntModel):
    __tablename__ = "test_object5"

    obj5_field: Mapped[str] = mapped_column(String(100), nullable=False)
    is_it_true: Mapped[bool] = mapped_column(
        Boolean(), nullable=False, server_default="true"
    )


class EntTestObject5(Ent[ExampleViewerContext]):
    vc: ExampleViewerContext
    model: EntTestObject5Model

    def __init__(self, vc: ExampleViewerContext, model: EntTestObject5Model) -> None:
        self.vc = vc
        self.model = model

    @property
    def id(self) -> UUID:
        return self.model.id

    @property
    def created_at(self) -> datetime:
        return self.model.created_at

    @property
    def updated_at(self) -> datetime:
        return self.model.updated_at

    @property
    def obj5_field(self) -> str:
        return self.model.obj5_field

    @property
    def is_it_true(self) -> bool:
        return self.model.is_it_true

    async def _gen_evaluate_privacy(
        self, vc: ExampleViewerContext, action: Action
    ) -> Decision:
        rules = EntTestObject5Schema().get_privacy_rules(action)
        for rule in rules:
            decision = await rule.gen_evaluate(vc, self)
            # If we get an ALLOW or DENY, we return instantly. Else, we keep going.
            if decision != Decision.PASS:
                return decision
        # We default to denying
        return Decision.DENY

    @classmethod
    async def genx(cls, vc: ExampleViewerContext, ent_id: UUID | str) -> EntTestObject5:
        ent = await cls.gen(vc, ent_id)
        if not ent:
            raise EntNotFoundError(f"No EntTestObject5 found for ID {ent_id}")
        return ent

    @classmethod
    async def gen(
        cls, vc: ExampleViewerContext, ent_id: UUID | str
    ) -> EntTestObject5 | None:
        # Convert str to UUID if needed
        if isinstance(ent_id, str):
            try:
                ent_id = UUID(ent_id)
            except ValueError as e:
                raise ValidationError(f"Invalid ID format for {ent_id}") from e

        session = get_session()
        model = await session.get(EntTestObject5Model, ent_id)
        return await cls._gen_from_model(vc, model)  # noqa: SLF001

    @classmethod
    async def _gen_from_model(
        cls, vc: ExampleViewerContext, model: EntTestObject5Model | None
    ) -> EntTestObject5 | None:
        if not model:
            return None
        ent = EntTestObject5(vc=vc, model=model)
        decision = await ent._gen_evaluate_privacy(vc=vc, action=Action.READ)
        return ent if decision == Decision.ALLOW else None

    @classmethod
    async def _genx_from_model(
        cls, vc: ExampleViewerContext, model: EntTestObject5Model
    ) -> EntTestObject5:
        ent = await EntTestObject5._gen_from_model(vc=vc, model=model)
        if not ent:
            raise EntNotFoundError(f"No EntTestObject5 found for ID {model.id}")
        return ent

    @classmethod
    def query(cls, vc: ExampleViewerContext) -> EntTestObject5Query:
        return EntTestObject5Query(vc=vc)


T = TypeVar("T")


class EntTestObject5Query(EntQuery[EntTestObject5, EntTestObject5Model]):
    vc: ExampleViewerContext

    def __init__(self, vc: ExampleViewerContext) -> None:
        self.vc = vc

        self.query = select(EntTestObject5Model)

    async def gen(self) -> list[EntTestObject5]:
        session = get_session()
        result = await session.execute(self.query)
        ents = await self._gen_ents(result)
        return list(filter(None, ents))

    async def _gen_ents(
        self, result: Result[tuple[EntTestObject5Model]]
    ) -> list[EntTestObject5 | None]:
        models = result.scalars().all()
        return [
            await EntTestObject5._gen_from_model(self.vc, model)  # noqa: SLF001
            for model in models
        ]

    async def gen_first(self) -> EntTestObject5 | None:
        session = get_session()
        result = await session.execute(self.query.limit(1))
        return await self._gen_ent(result)

    async def _gen_ent(
        self, result: Result[tuple[EntTestObject5Model]]
    ) -> EntTestObject5 | None:
        model = result.scalar_one_or_none()
        return await EntTestObject5._gen_from_model(self.vc, model)  # noqa: SLF001

    async def genx_first(self) -> EntTestObject5:
        ent = await self.gen_first()
        if not ent:
            raise EntNotFoundError("Expected query to return an ent, got None.")
        return ent

    async def gen_count_NO_PRIVACY(self) -> int:
        session = get_session()
        count_query = self.query.with_only_columns(
            func.count(), maintain_column_froms=True
        ).order_by(None)
        result = await session.execute(count_query)
        count = result.scalar()
        if count is None:
            raise ExecutionError("Unable to get the count")
        return count

    def order_by_id_asc(self) -> "EntTestObject5Query":
        self.query = self.query.order_by(EntTestObject5Model.id.asc())
        return self

    def order_by_id_desc(self) -> "EntTestObject5Query":
        self.query = self.query.order_by(EntTestObject5Model.id.desc())
        return self


class EntTestObject5Mutator:
    @classmethod
    def create(
        cls,
        vc: ExampleViewerContext,
        obj5_field: str,
        is_it_true: bool = True,
        id: UUID | None = None,
        created_at: datetime | None = None,
        updated_at: datetime | None = None,
    ) -> EntTestObject5MutatorCreationAction:
        return EntTestObject5MutatorCreationAction(
            vc=vc,
            id=id,
            created_at=created_at,
            updated_at=updated_at,
            obj5_field=obj5_field,
            is_it_true=is_it_true,
        )

    @classmethod
    def update(
        cls, vc: ExampleViewerContext, ent: EntTestObject5
    ) -> EntTestObject5MutatorUpdateAction:
        return EntTestObject5MutatorUpdateAction(vc=vc, ent=ent)

    @classmethod
    def delete(
        cls, vc: ExampleViewerContext, ent: EntTestObject5
    ) -> EntTestObject5MutatorDeletionAction:
        return EntTestObject5MutatorDeletionAction(vc=vc, ent=ent)


class EntTestObject5MutatorCreationAction:
    vc: ExampleViewerContext
    id: UUID
    obj5_field: str
    is_it_true: bool

    def __init__(
        self,
        vc: ExampleViewerContext,
        id: UUID | None,
        created_at: datetime | None,
        updated_at: datetime | None,
        obj5_field: str,
        is_it_true: bool,
    ) -> None:
        self.vc = vc
        self.created_at = created_at if created_at else datetime.now(tz=UTC)
        self.updated_at = updated_at if updated_at else self.created_at
        self.id = id if id else generate_uuid(EntTestObject5, self.created_at)
        self.obj5_field = obj5_field
        self.is_it_true = is_it_true

    async def gen_savex(self) -> EntTestObject5:
        session = get_session()

        model = EntTestObject5Model(
            id=self.id,
            updated_at=self.updated_at,
            created_at=self.created_at,
            obj5_field=self.obj5_field,
            is_it_true=self.is_it_true,
        )
        session.add(model)
        await session.flush()
        # TODO privacy checks
        return await EntTestObject5._genx_from_model(self.vc, model)  # noqa: SLF001


class EntTestObject5MutatorUpdateAction:
    vc: ExampleViewerContext
    ent: EntTestObject5
    id: UUID
    obj5_field: str
    is_it_true: bool

    def __init__(self, vc: ExampleViewerContext, ent: EntTestObject5) -> None:
        self.vc = vc
        self.ent = ent
        self.obj5_field = ent.obj5_field
        self.is_it_true = ent.is_it_true

    async def gen_savex(self) -> EntTestObject5:
        session = get_session()

        model = self.ent.model
        model.obj5_field = self.obj5_field
        model.is_it_true = self.is_it_true
        model.updated_at = datetime.now(tz=UTC)
        session.add(model)
        await session.flush()
        await session.refresh(model)
        # TODO privacy checks
        return await EntTestObject5._genx_from_model(self.vc, model)  # noqa: SLF001


class EntTestObject5MutatorDeletionAction:
    vc: ExampleViewerContext
    ent: EntTestObject5

    def __init__(self, vc: ExampleViewerContext, ent: EntTestObject5) -> None:
        self.vc = vc
        self.ent = ent

    async def gen_save(self) -> None:
        session = get_session()
        model = self.ent.model
        # TODO privacy checks
        await session.delete(model)
        await session.flush()


class EntTestObject5Example:
    @classmethod
    async def gen_create(
        cls,
        vc: ExampleViewerContext,
        created_at: datetime | None = None,
        obj5_field: str | Sentinel = NOTHING,
        is_it_true: bool | Sentinel = NOTHING,
    ) -> EntTestObject5:
        # TODO make sure we only use this in test mode

        obj5_field = "blah!" if isinstance(obj5_field, Sentinel) else obj5_field

        is_it_true = True if isinstance(is_it_true, Sentinel) else is_it_true

        return await EntTestObject5Mutator.create(
            vc=vc, created_at=created_at, obj5_field=obj5_field, is_it_true=is_it_true
        ).gen_savex()


def _get_field(field_name: str) -> Field:
    schema = EntTestObject5Schema()
    fields = schema.get_all_fields()
    field = next(
        filter(
            lambda field: field.name == field_name,
            fields,
        )
    )
    if not field:
        raise ValueError(f"Unknown field: {field_name}")
    return field

####################
# Code generated by EntPy - do not modify manually!
####################

from __future__ import annotations
from abc import ABC, abstractmethod
from uuid import UUID
from entpy import Ent, ValidationError
from datetime import datetime
from sentinels import Sentinel, NOTHING  # type: ignore
from typing import Self
from sqlalchemy import select, Select, func, Result
from sqlalchemy import String
from evc import ExampleViewerContext
from .ent_model import EntModel
from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy import Enum as DBEnum
from ent_test_thing_pattern import ThingStatus
from typing import cast
from typing import Any, TypeVar, Generic
from sqlalchemy.sql.expression import ColumnElement
from database import get_session
from entpy import EntNotFoundError, ExecutionError


class EntTestThingModel(EntModel):
    __abstract__ = True

    a_good_thing: Mapped[str] = mapped_column(String(100), nullable=False)
    thing_status: Mapped[ThingStatus | None] = mapped_column(
        DBEnum(ThingStatus, native_enum=True), nullable=True
    )


class IEntTestThing(Ent):
    @property
    @abstractmethod
    def a_good_thing(self) -> str:
        pass

    @property
    @abstractmethod
    def thing_status(self) -> ThingStatus | None:
        pass

    @classmethod
    async def gen(
        cls, vc: ExampleViewerContext, ent_id: UUID | str
    ) -> IEntTestThing | None:
        # Convert str to UUID if needed
        if isinstance(ent_id, str):
            try:
                ent_id = UUID(ent_id)
            except ValueError as e:
                raise ValidationError(f"Invalid ID format for {ent_id}") from e

        # TODO refactor this to read the bytes from the UUID

        from .ent_test_object2 import EntTestObject2

        ent_test_object2 = await EntTestObject2.gen(vc, ent_id)
        if ent_test_object2:
            return ent_test_object2

        from .ent_test_object import EntTestObject

        ent_test_object = await EntTestObject.gen(vc, ent_id)
        if ent_test_object:
            return ent_test_object

        return None

    @classmethod
    async def genx(cls, vc: ExampleViewerContext, ent_id: UUID | str) -> IEntTestThing:
        # Convert str to UUID if needed
        if isinstance(ent_id, str):
            try:
                ent_id = UUID(ent_id)
            except ValueError as e:
                raise ValidationError(f"Invalid ID format for {ent_id}") from e

        # TODO refactor this to read the bytes from the UUID

        from .ent_test_object2 import EntTestObject2

        ent_test_object2 = await EntTestObject2.gen(vc, ent_id)
        if ent_test_object2:
            return ent_test_object2

        from .ent_test_object import EntTestObject

        ent_test_object = await EntTestObject.gen(vc, ent_id)
        if ent_test_object:
            return ent_test_object

        raise ValueError(f"No EntTestThing found for ID {ent_id}")

    @classmethod
    def query_ent_test_thing(cls, vc: ExampleViewerContext) -> IEntTestThingListQuery:
        return IEntTestThingListQuery(vc=vc)

    @classmethod
    def query_ent_test_thing_count(
        cls, vc: ExampleViewerContext
    ) -> IEntTestThingCountQuery:
        return IEntTestThingCountQuery()


T = TypeVar("T")


class IEntTestThingQuery(ABC, Generic[T]):
    query: Select[tuple[T]]

    def join(self, model_class: type[EntModel], predicate: ColumnElement[bool]) -> Self:
        self.query = self.query.join(model_class, predicate)
        return self

    def where(self, predicate: ColumnElement[bool]) -> Self:
        self.query = self.query.where(predicate)
        return self

    def order_by(self, predicate: ColumnElement[Any]) -> Self:
        self.query = self.query.order_by(predicate)
        return self

    def limit(self, limit: int) -> Self:
        self.query = self.query.limit(limit)
        return self

    def offset(self, offset: int) -> Self:
        self.query = self.query.offset(offset)
        return self


class IEntTestThingListQuery(IEntTestThingQuery[UUID]):
    vc: ExampleViewerContext

    def __init__(self, vc: ExampleViewerContext) -> None:
        self.vc = vc
        from .ent_test_thing_view import EntTestThingView

        self.query = select(EntTestThingView.__table__)

    async def gen(self) -> list[IEntTestThing]:
        session = get_session()
        result = await session.execute(self.query)
        ents = await self._gen_ents(result)
        return list(filter(None, ents))

    async def _gen_ents(
        self, result: Result[tuple[UUID]]
    ) -> list[IEntTestThing | None]:
        ent_ids = result.scalars().all()
        return [await self._gen_single_ent(ent_id) for ent_id in ent_ids]

    async def gen_first(self) -> IEntTestThing | None:
        session = get_session()
        result = await session.execute(self.query.limit(1))
        return await self._gen_ent(result)

    async def _gen_ent(self, result: Result[tuple[UUID]]) -> IEntTestThing | None:
        ent_id = result.scalar_one_or_none()
        if not ent_id:
            return None
        return await self._gen_single_ent(ent_id)

    async def _gen_single_ent(self, ent_id: UUID) -> IEntTestThing | None:
        from .all_models import UUID_TO_ENT

        uuid_type = ent_id.bytes[6:8]
        ent_type = UUID_TO_ENT[uuid_type]
        # Casting is ok here, the id always inherits IEntTestThing
        return await cast(type[IEntTestThing], ent_type).gen(self.vc, ent_id)

    async def genx_first(self) -> IEntTestThing:
        ent = await self.gen_first()
        if not ent:
            raise EntNotFoundError("Expected query to return an ent, got None.")
        return ent


class IEntTestThingCountQuery(IEntTestThingQuery[int]):
    def __init__(self) -> None:
        from .ent_test_thing_view import EntTestThingView

        self.query = select(func.count()).select_from(EntTestThingView.__table__)

    async def gen_NO_PRIVACY(self) -> int:
        session = get_session()
        result = await session.execute(self.query)
        count = result.scalar()
        if count is None:
            raise ExecutionError("Unable to get the count")
        return count


class IEntTestThingExample:
    @classmethod
    async def gen_create(
        cls,
        vc: ExampleViewerContext,
        created_at: datetime | None = None,
        a_good_thing: str | Sentinel = NOTHING,
        thing_status: ThingStatus | None = None,
    ) -> IEntTestThing:
        # TODO make sure we only use this in test mode

        # EntPy selected a random implementation of the pattern to use for examples
        from .ent_test_object2 import EntTestObject2Example

        return await EntTestObject2Example.gen_create(
            vc=vc,
            created_at=created_at,
            a_good_thing=a_good_thing,
            thing_status=thing_status,
        )

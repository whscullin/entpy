####################
# Code generated by EntPy - do not modify manually!
####################

from __future__ import annotations
from abc import ABC, abstractmethod
from uuid import UUID
from entpy import Ent, ValidationError
from datetime import datetime
from sentinels import Sentinel, NOTHING  # type: ignore
from .ent_model import EntModel
from .ent_query import EntQuery
from database import get_session
from ent_test_thing_pattern import ThingStatus
from entpy import EntNotFoundError, ExecutionError
from evc import ExampleViewerContext
from sqlalchemy import Enum as DBEnum
from sqlalchemy import ForeignKey
from sqlalchemy import String
from sqlalchemy import UUID as DBUUID
from sqlalchemy import select, func, Result
from sqlalchemy.orm import Mapped, mapped_column
from typing import TypeVar
from typing import cast

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from .ent_test_object5 import EntTestObject5


class EntTestThingModel(EntModel):
    __abstract__ = True

    a_good_thing: Mapped[str] = mapped_column(String(100), nullable=False)
    obj5_id: Mapped[UUID] = mapped_column(
        DBUUID(), ForeignKey("test_object5.id"), nullable=False
    )
    a_pattern_validated_field: Mapped[str | None] = mapped_column(
        String(100), nullable=True
    )
    obj5_opt_id: Mapped[UUID | None] = mapped_column(
        DBUUID(), ForeignKey("test_object5.id"), nullable=True
    )
    thing_status: Mapped[ThingStatus | None] = mapped_column(
        DBEnum(ThingStatus, native_enum=True), nullable=True
    )


class IEntTestThing(Ent):
    @property
    @abstractmethod
    def a_good_thing(self) -> str:
        pass

    @property
    @abstractmethod
    def obj5_id(self) -> UUID:
        pass

    @property
    @abstractmethod
    def a_pattern_validated_field(self) -> str | None:
        pass

    @property
    @abstractmethod
    def obj5_opt_id(self) -> UUID | None:
        pass

    @property
    @abstractmethod
    def thing_status(self) -> ThingStatus | None:
        pass

    @abstractmethod
    async def gen_obj5(self) -> "EntTestObject5":
        pass

    @abstractmethod
    async def gen_obj5_opt(self) -> "EntTestObject5" | None:
        pass

    @classmethod
    async def gen(
        cls, vc: ExampleViewerContext, ent_id: UUID | str
    ) -> IEntTestThing | None:
        # Convert str to UUID if needed
        if isinstance(ent_id, str):
            try:
                ent_id = UUID(ent_id)
            except ValueError as e:
                raise ValidationError(f"Invalid ID format for {ent_id}") from e

        # TODO refactor this to read the bytes from the UUID

        from .ent_test_object2 import EntTestObject2

        ent_test_object2 = await EntTestObject2.gen(vc, ent_id)
        if ent_test_object2:
            return ent_test_object2

        from .ent_test_object import EntTestObject

        ent_test_object = await EntTestObject.gen(vc, ent_id)
        if ent_test_object:
            return ent_test_object

        return None

    @classmethod
    async def genx(cls, vc: ExampleViewerContext, ent_id: UUID | str) -> IEntTestThing:
        # Convert str to UUID if needed
        if isinstance(ent_id, str):
            try:
                ent_id = UUID(ent_id)
            except ValueError as e:
                raise ValidationError(f"Invalid ID format for {ent_id}") from e

        # TODO refactor this to read the bytes from the UUID

        from .ent_test_object2 import EntTestObject2

        ent_test_object2 = await EntTestObject2.gen(vc, ent_id)
        if ent_test_object2:
            return ent_test_object2

        from .ent_test_object import EntTestObject

        ent_test_object = await EntTestObject.gen(vc, ent_id)
        if ent_test_object:
            return ent_test_object

        raise ValueError(f"No EntTestThing found for ID {ent_id}")

    @classmethod
    def query_ent_test_thing(cls, vc: ExampleViewerContext) -> IEntTestThingQuery:
        return IEntTestThingQuery(vc=vc)


T = TypeVar("T")


class IEntTestThingQuery(EntQuery[IEntTestThing, UUID]):
    vc: ExampleViewerContext

    def __init__(self, vc: ExampleViewerContext) -> None:
        self.vc = vc
        from .ent_test_thing_view import EntTestThingView

        self.query = select(EntTestThingView.__table__)

    async def gen(self) -> list[IEntTestThing]:
        session = get_session()
        result = await session.execute(self.query)
        ents = await self._gen_ents(result)
        return list(filter(None, ents))

    async def _gen_ents(
        self, result: Result[tuple[UUID]]
    ) -> list[IEntTestThing | None]:
        ent_ids = result.scalars().all()
        return [await self._gen_single_ent(ent_id) for ent_id in ent_ids]

    async def gen_first(self) -> IEntTestThing | None:
        session = get_session()
        result = await session.execute(self.query.limit(1))
        return await self._gen_ent(result)

    async def _gen_ent(self, result: Result[tuple[UUID]]) -> IEntTestThing | None:
        ent_id = result.scalar_one_or_none()
        if not ent_id:
            return None
        return await self._gen_single_ent(ent_id)

    async def _gen_single_ent(self, ent_id: UUID) -> IEntTestThing | None:
        from .all_models import UUID_TO_ENT

        uuid_type = ent_id.bytes[6:8]
        ent_type = UUID_TO_ENT[uuid_type]
        # Casting is ok here, the id always inherits IEntTestThing
        return await cast(type[IEntTestThing], ent_type).gen(self.vc, ent_id)

    async def genx_first(self) -> IEntTestThing:
        ent = await self.gen_first()
        if not ent:
            raise EntNotFoundError("Expected query to return an ent, got None.")
        return ent

    async def gen_count_NO_PRIVACY(self) -> int:
        session = get_session()
        count_query = self.query.with_only_columns(
            func.count(), maintain_column_froms=True
        ).order_by(None)
        result = await session.execute(count_query)
        count = result.scalar()
        if count is None:
            raise ExecutionError("Unable to get the count")
        return count

    def order_by_id_asc(self) -> "IEntTestThingQuery":
        from .ent_test_thing_view import EntTestThingView

        self.query = self.query.order_by(EntTestThingView.id.asc())
        return self

    def order_by_id_desc(self) -> "IEntTestThingQuery":
        from .ent_test_thing_view import EntTestThingView

        self.query = self.query.order_by(EntTestThingView.id.desc())
        return self


class IEntTestThingMutator:
    @classmethod
    def update(
        cls, vc: ExampleViewerContext, ent: IEntTestThing
    ) -> IEntTestThingMutatorUpdateAction:
        from .ent_test_object2 import EntTestObject2

        if isinstance(ent, EntTestObject2):
            from .ent_test_object2 import EntTestObject2Mutator

            return EntTestObject2Mutator.update(vc, ent)

        from .ent_test_object import EntTestObject

        if isinstance(ent, EntTestObject):
            from .ent_test_object import EntTestObjectMutator

            return EntTestObjectMutator.update(vc, ent)

        raise ValueError(f"Unknown implementation for IEntTestThing: {type(ent)}")

    @classmethod
    def delete(
        cls, vc: ExampleViewerContext, ent: IEntTestThing
    ) -> IEntTestThingMutatorDeletionAction:
        from .ent_test_object2 import EntTestObject2

        if isinstance(ent, EntTestObject2):
            from .ent_test_object2 import EntTestObject2Mutator

            return EntTestObject2Mutator.delete(vc, ent)

        from .ent_test_object import EntTestObject

        if isinstance(ent, EntTestObject):
            from .ent_test_object import EntTestObjectMutator

            return EntTestObjectMutator.delete(vc, ent)

        raise ValueError(f"Unknown implementation for IEntTestThing: {type(ent)}")


class IEntTestThingMutatorUpdateAction(ABC):
    vc: ExampleViewerContext
    ent: IEntTestThing
    a_good_thing: str
    obj5_id: UUID
    a_pattern_validated_field: str | None
    obj5_opt_id: UUID | None
    thing_status: ThingStatus | None

    @abstractmethod
    async def gen_savex(self) -> IEntTestThing:
        pass


class IEntTestThingMutatorDeletionAction(ABC):
    vc: ExampleViewerContext
    ent: IEntTestThing

    @abstractmethod
    async def gen_save(self) -> None:
        pass


class IEntTestThingExample:
    @classmethod
    async def gen_create(
        cls,
        vc: ExampleViewerContext,
        created_at: datetime | None = None,
        a_good_thing: str | Sentinel = NOTHING,
        obj5_id: UUID | Sentinel = NOTHING,
        a_pattern_validated_field: str | None = None,
        obj5_opt_id: UUID | None = None,
        thing_status: ThingStatus | None = None,
    ) -> IEntTestThing:
        # TODO make sure we only use this in test mode

        from .ent_test_object import EntTestObjectExample

        return await EntTestObjectExample.gen_create(
            vc=vc,
            created_at=created_at,
            a_good_thing=a_good_thing,
            obj5_id=obj5_id,
            a_pattern_validated_field=a_pattern_validated_field,
            obj5_opt_id=obj5_opt_id,
            thing_status=thing_status,
        )

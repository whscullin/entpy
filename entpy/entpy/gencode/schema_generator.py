import re

from entpy import EdgeField, Schema
from entpy.framework.fields.enum_field import EnumField
from entpy.gencode.base_generator import generate as generate_base
from entpy.gencode.example_generator import generate as generate_example
from entpy.gencode.introspection_generator import generate as generate_introspection
from entpy.gencode.model_generator import generate as generate_model
from entpy.gencode.mutator_generator import generate as generate_mutator
from entpy.gencode.query_generator import generate as generate_query


def generate(
    schema_class: type[Schema],
    ent_model_import: str,
    session_getter_import: str,
    session_getter_fn_name: str,
    vc_import: str,
    vc_name: str,
) -> str:
    schema = schema_class()
    base_name = schema_class.__name__.replace("Schema", "")

    # Validate that the schema has at least one field
    _validate_has_fields(schema)
    # Validate that all field names are unique
    _validate_unique_field_names(schema)
    # Validate that EdgeFields don't end with _id
    _validate_edge_field_names(schema)
    # Validate that field names only contain lowercase letters, numbers, and underscores
    _validate_field_name_format(schema)

    model_content = generate_model(descriptor=schema, base_name=base_name)
    base_content = generate_base(
        schema=schema,
        base_name=base_name,
        session_getter_fn_name=session_getter_fn_name,
        vc_name=vc_name,
    )
    query_content = generate_query(
        descriptor=schema,
        base_name=base_name,
        session_getter_fn_name=session_getter_fn_name,
        vc_name=vc_name,
    )
    mutator_content = generate_mutator(
        schema=schema,
        base_name=base_name,
        session_getter_fn_name=session_getter_fn_name,
        vc_name=vc_name,
    )
    example_content = generate_example(
        schema=schema, base_name=base_name, vc_name=vc_name
    )
    introspection_code = generate_introspection(base_name=base_name)

    type_checking_imports = (
        model_content.type_checking_imports
        + base_content.type_checking_imports
        + query_content.type_checking_imports
        + mutator_content.type_checking_imports
        + example_content.type_checking_imports
    )

    imports = (
        [ent_model_import]
        + model_content.imports
        + base_content.imports
        + query_content.imports
        + mutator_content.imports
        + example_content.imports
        + _get_patterns_imports(schema)
    )
    if type_checking_imports:
        imports.append("from typing import TYPE_CHECKING")
    imports = sorted(set(imports))  # Remove duplicates
    imports_code = "\n".join(imports)
    type_checking_imports_code = (
        "if TYPE_CHECKING:\n    " + "\n    ".join(type_checking_imports)
        if type_checking_imports
        else ""
    )

    return f"""####################
# Code generated by EntPy - do not modify manually!
####################

from __future__ import annotations
from entpy import Ent, generate_uuid, EntNotFoundError, ExecutionError, Action, Decision, ValidationError
from uuid import UUID
from datetime import datetime, UTC
from typing import Self
from abc import ABC
{vc_import}
{session_getter_import}
{imports_code}
{type_checking_imports_code}

{model_content.code}

{base_content.code}

{query_content.code}

{mutator_content.code}

{example_content.code}

{introspection_code}
"""


def _validate_has_fields(schema: Schema) -> None:
    """Validate that the schema has at least one field (from schema or patterns)."""
    all_fields = schema.get_all_fields()
    if not all_fields:
        raise ValueError(
            f"{schema.__class__.__name__} must have at least one field. "
            f"Define fields in the schema itself or include patterns that provide fields."
        )


def _validate_unique_field_names(schema: Schema) -> None:
    """Validate that all field names (from schema and patterns) are unique."""
    all_fields = schema.get_all_fields()
    field_names = [field.name for field in all_fields]
    duplicates = [name for name in field_names if field_names.count(name) > 1]

    if duplicates:
        unique_duplicates = sorted(set(duplicates))
        raise ValueError(
            f"Duplicate field names found in {schema.__class__.__name__}: {', '.join(unique_duplicates)}"
        )


def _validate_edge_field_names(schema: Schema) -> None:
    """Validate that EdgeField names don't end with _id."""
    all_fields = schema.get_all_fields()
    invalid_edge_fields = [
        field.original_name
        for field in all_fields
        if isinstance(field, EdgeField) and field.original_name.endswith("_id")
    ]

    if invalid_edge_fields:
        raise ValueError(
            f"EdgeField names in {schema.__class__.__name__} should not end with '_id' "
            f"(this suffix is added automatically by EntPy): {', '.join(invalid_edge_fields)}"
        )


def _validate_field_name_format(schema: Schema) -> None:
    """Validate that field names only contain lowercase letters, numbers, and underscores."""
    all_fields = schema.get_all_fields()
    pattern = re.compile(r"^[a-z0-9_]+$")
    invalid_fields = [
        field.original_name
        for field in all_fields
        if not pattern.match(field.original_name)
    ]

    if invalid_fields:
        raise ValueError(
            f"Field names in {schema.__class__.__name__} must only contain lowercase letters, "
            f"numbers, and underscores: {', '.join(invalid_fields)}"
        )


def _get_patterns_imports(schema: Schema) -> list[str]:
    # If a pattern has EnumFields, we need to import the Enum type
    patterns = schema.get_patterns()
    imports = []

    for pattern in patterns:
        for field in pattern.get_all_fields():
            if isinstance(field, EnumField):
                enum_type = field.enum_class
                module = enum_type.__module__
                import_statement = f"from {module} import {enum_type.__name__}"
                imports.append(import_statement)

    return imports

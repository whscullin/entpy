from entpy import Pattern, Schema
from entpy.framework.fields.edge_field import EdgeField
from entpy.gencode.model_generator import generate as generate_model
from entpy.gencode.query_generator import generate as generate_query
from entpy.gencode.utils import get_description, to_snake_case
from entpy.gencode.generated_content import GeneratedContent


def generate(
    pattern_class: type[Pattern],
    children_schema_classes: list[type[Schema]],
    ent_model_import: str,
    session_getter_import: str,
    session_getter_fn_name: str,
    vc_import: str,
    vc_name: str,
) -> str:
    pattern = pattern_class()
    base_name = pattern_class.__name__.replace("Pattern", "")

    model = generate_model(descriptor=pattern, base_name=base_name)

    # Let's make sure that we require the properties for the pattern fields
    properties = ""
    for field in pattern.get_all_fields():
        properties += f"""
    @property
    @abstractmethod
    def {field.name}(self) -> {field.get_python_type()}{" | None" if field.nullable else ""}:
        pass
"""  # noqa: E501

    # We are trying to load the various subclasses of ents
    loaders_gen = _get_loaders(children_schema_classes=children_schema_classes)

    gen_edges = _generate_edges(pattern=pattern, base_name=base_name, vc_name=vc_name)

    query_content = generate_query(
        descriptor=pattern,
        base_name=base_name,
        session_getter_fn_name=session_getter_fn_name,
        vc_name=vc_name,
    )

    # Get the first implementation we can find to use for the example
    if not children_schema_classes:
        raise ValueError(f"No concrete implementation found for {base_name}")
    schema_class = children_schema_classes[0]
    example_base_name = schema_class.__name__.replace("Schema", "")

    # Generate the arguments for the gen_create function of the example
    example_arguments_definition = ""
    example_arguments_assignment = ""
    for field in pattern.get_all_fields():
        example_arguments_definition += f", {field.name}: {field.get_python_type()}"
        example_arguments_definition += (
            " | None = None" if field.nullable else " | Sentinel = NOTHING"
        )
        example_arguments_assignment += f", {field.name}={field.name}"

    # Make sure to import all the things!
    imports = (
        [vc_import, ent_model_import, session_getter_import]
        + model.imports
        + query_content.imports
        + gen_edges.imports
    )
    imports = list(set(imports))  # Remove duplicates
    imports_code = "\n".join(imports)

    type_checking_imports = gen_edges.type_checking_imports
    if type_checking_imports:
        imports_code += "\n\nfrom typing import TYPE_CHECKING\n\n"
        imports_code += "if TYPE_CHECKING:\n"
        for imp in type_checking_imports:
            imports_code += f"    {imp}\n"

    return f"""####################
# Code generated by EntPy - do not modify manually!
####################

from __future__ import annotations
from abc import ABC, abstractmethod
from uuid import UUID
from entpy import Ent, ValidationError
from datetime import datetime
from sentinels import Sentinel, NOTHING  # type: ignore
from typing import Self
{imports_code}

{model.code}

class I{base_name}(Ent):{get_description(pattern)}
    {properties}

{gen_edges.code}

    @classmethod
    async def gen(cls, vc: {vc_name}, ent_id: UUID | str) -> I{base_name} | None:
        # Convert str to UUID if needed
        if isinstance(ent_id, str):
            try:
                ent_id = UUID(ent_id)
            except ValueError as e:
                raise ValidationError(f"Invalid ID format for {{ent_id}}") from e

        # TODO refactor this to read the bytes from the UUID
        {loaders_gen}
        return None

    @classmethod
    async def genx(cls, vc: {vc_name}, ent_id: UUID | str) -> I{base_name}:
        # Convert str to UUID if needed
        if isinstance(ent_id, str):
            try:
                ent_id = UUID(ent_id)
            except ValueError as e:
                raise ValidationError(f"Invalid ID format for {{ent_id}}") from e

        # TODO refactor this to read the bytes from the UUID
        {loaders_gen}
        raise ValueError(f"No {base_name} found for ID {{ent_id}}")

    @classmethod
    def query_{to_snake_case(base_name)}(cls, vc: {vc_name}) -> I{base_name}Query:
        return I{base_name}Query(vc=vc)

{query_content.code}

class I{base_name}Example:
    @classmethod
    async def gen_create(
        cls, vc: {vc_name}, created_at: datetime | None = None{example_arguments_definition}
    ) -> I{base_name}:
        # TODO make sure we only use this in test mode

        # EntPy selected a random implementation of the pattern to use for examples
        from .{to_snake_case(example_base_name)} import {example_base_name}Example

        return await {example_base_name}Example.gen_create(vc=vc, created_at=created_at{example_arguments_assignment})
"""  # noqa: E501


def _get_loaders(children_schema_classes: list[type[Schema]]) -> str:
    loaders = ""
    for schema_class in children_schema_classes:
        schema_base_name = schema_class.__name__.replace("Schema", "")
        lower_schema = to_snake_case(schema_base_name)
        loaders += f"""
        from .{lower_schema} import {schema_base_name}
        {lower_schema} = await {schema_base_name}.gen(vc, ent_id)
        if {lower_schema}:
            return {lower_schema}
"""
    return loaders


def _generate_edges(pattern: Pattern, base_name: str, vc_name: str) -> GeneratedContent:
    code = ""
    type_checking_imports = []
    for field in pattern.get_all_fields():
        if isinstance(field, EdgeField):
            or_not = " | None" if field.nullable else ""
            if field.edge_class != pattern.__class__:
                module = "." + to_snake_case(
                    field.edge_class.__name__.replace("Schema", "").replace(
                        "Pattern", ""
                    )
                )
                type_checking_imports.append(
                    f"from {module} import {field.get_edge_type()}"
                )
            code += f"""

    @abstractmethod
    async def gen_{field.original_name}(self) -> "{field.get_edge_type()}"{or_not}:
        pass
"""
    return GeneratedContent(
        imports=["from abc import abstractmethod"] if code else [],
        code=code,
        type_checking_imports=type_checking_imports,
    )
